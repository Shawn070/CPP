# 1. 作用域分辨符
``` c++
类名::成员名			// 数据成员
类名::成员名(参数表)	// 函数成员
```
可见性原则: 如果存在两个或多个具有包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层仍然可见; 如果在内层声明了同名标识符，则在城。外层标识符在内层不可见。
>细节: 如果子类中定义的函数与父类的函数同名但具有不同的参数，不属于函数重载，这时子类中的函数将使父类中的函数隐藏，调用父类中的函数必须使用父类名称来限定。**只有在相同的作用域中定义的函数才可以重载。**
>详见: 7.6.cpp

# 2. 虚基类
当某类的部分或全部直接基类是从另一个共同基类派生而来时，在这些直接基类中从上一级共同基类继承来的成员就拥有相同的名称。可以使用作用域分辨符来唯一标识并访问他们，也可以将共同基类设置为**虚基类**，这时不同路径继承过来的同名函数成员在内存中就只有一个副本，同名函数名也只有一个映。相比之下，前者可以容纳更多的数据，而后者使用更为方便，内存空间更为节省。
`class 派生类名: virtual 继承方式 基类名`

# 3. 虚基类及其派生类构造函数
如果虚基类声明有非默认形式的(即带形参的)构造函数，并且没有声明默认形式的构造函数，在整个继承关系中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化列表中列出对虚基类的初始化。
>详见7_8.cpp
最远派生类: 建立对象时所指定的类称为方式的最远派生类。
如7_8中对象建立d时，Derived就是最远派生类。建立一个对象时的，如果这个对象中含有从虚基类继承来的成员，则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。而且，只有最远派生类的构造函数会调用虚基类的构造函数，该派生类的其他基类，(例如 Base1,Base2类)对虚基类构造函数的调用都会自动被忽略。





