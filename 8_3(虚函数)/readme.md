如果需要通过基类的指针指向派生类的对象，并访问某个与基类同名的成员，那么首先在基类中将这个同函数说明为虚函数。这样，通过基类类型的指针，就可以使属于不同派生类的不同对象产生不同的行为，从而实现运行过程的多态。
# 1. 一般虚函数成员
`virtual 函数类型 函数名(形参表);`
>***函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候。***
运行过程中的多态需要满足:
	1. 类之间满足赋值兼容规则;
	2. 要声明虚函数;
	3. 由成员函数来调用或者是通过指针、引用来访问虚函数。

判断派生类的一个函数成员是不是虚函数，该函数是否与基类的虚函数有相同的: 1. 名称; 2. 参数个数及相对应参数类型; 3. 返回值或者满足赋值兼容规则的指针、引用型的返回值。
如果满足上述条件，则派生类的虚函数便覆盖了基类的虚函数，并且派生类中的虚函数还会隐藏基类中同名函数的所有其他重载形式。
>派生类覆盖基类的成员函数时，既可以使用virtual关键字，也可以不使用，一般会使用以提示这是一个虚函数。

只有虚函数是动态绑定的，如果派生类需要修改基类的行为(即重写与基类函数同名的函数)，就应该在基类中将相应的函数声明为虚函数。
>在重写继承来的虚函数时，如果函数有默认形参，不要重新定义不同的值。因为: 虽然虚函数是动态绑定的，但默认形参值是静态绑定的。

>>只有通过基类了。的指针或引用调用虚函数时，才会发生动态绑定。

# 2. 虚析构函数
`virtual ~类名();`
如果一个类的析构函数是虚函数，那么由他派生而来的所有子类的析构函数也是虚函数。析构函数设置为虚函数后，在使用指针引用时可以动态绑定，实现运行时的多态，保证使用基类类型的指针就能够调用适当的析构函数针对不同的对象进行清理工作。
简单来说，如果有可能通过基类指针调用对象的析构函数(通过delete)，就需要让基类的析构函数成为虚函数，否则会产生不确定的后果。





