# 1.多态类型与非多态类型
多态类型: 有虚函数的类型
非多态类型: 所有的其他类型
多态类型设计原则: 把多态类型的析构函数设定为虚函数

# 2. 运行时类型识别
基类的指针可以指向派生类的对象，通过这样的指针(或引用)，虽然可以利用多态性来执行派生类提供的功能，但这仅限于调用基类中声明的虚函数。如果希望对一部分派生类的对象，调用派生类中引入的新函数，则无法通过基类指针进行。
解决办法之一是 用static_cast 执行基类指针向派生类指针的显式转换(不太安全)，只能在指针所指向对象的类型明确的情况下执行。
c++提供两种运行时类型识别的机制:
1. 用dynamic_cast 执行基类向派生类的转换
将基类的指针(或引用)显示转换为派生类的指针(或引用).
但与static_cast 不同的是，有条件的转换，转换前会检测指针(或引用)所指的对象的实际类型是否与转换的目的类型兼容，否则:
* 如果执行的是指针类型的转换，会得到空指针。
* 如果执行的是引用类型的转换，会抛出异常。
> 转换前类型必须是指向多态类型的指针(或引用)，因为c++只为多态类型在运行时保存用于运行时类型识别的信息。

2. 用typeid获取运行时类型信息
> typeid是C++的一个关键字，用它可以获得一个类型的相关信息。
``` c++
typeid(表达式)	// typeid(5+3)
// 或者
typeid(类型说明符)	// typeid(int)
```
3. 虚函数动态绑定的实现原理 
关键：在运行时决定被调用的函数
* 最直接的方式：在每个对象中，除了存储数据成员外，还为每个虚函数设置一个指针，分别存放这些函数对应 代码的入口地址。缺点：占用的额外空间太大。
* 虚表：这些指针都可以保存一份，它们构成一个表
* 虚表指针：每个对象中不再保存一个个函数指针，而只是保存一个指向这个虚表首地址的指针
* 每个类各有一个虚表，虚表的内容是由编译器安排的。
* 每个多态类型的对象中都有一个指向当前类型的虚表的指针，该指针在构造函数中被赋值。
> 当通过基类的指针或引用调用一个虚函数时，就可以通过虚表指针找到该对象的虚表，进而找到存放虚函数的指针的虚表条目。将该条目中存放的指针读出后，就可获应当被调用的函数的入口地址，然后调用该虚函数，虚函数的动态绑定就是这样完成的。
>> 事实上，一个类的虚表中存放不只是虚函数的指针，用于支持运行时类型识别的对象的运行时类型信息也需要通过虚表来访问。只有多态类型有虚表，因此只有多态类型支持运行时类型识别。




 
 

