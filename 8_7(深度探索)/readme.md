# 1.…多态类型与非多态类型
多态类型: 有虚函数的类型
非多态类型: 所有的其他类型
多态类型设计原则: 把多态类型的析构函数设定为虚函数

# 2. 运行时类型识别
基类的指针可以指向派生类的对象，通过这样的指针(或引用)，虽然可以利用多态性来执行派生类提供的功能，但这仅限于调用基类中声明的虚函数。如果希望对一部分派生类的对象，调用派生类中引入的新函数，则无法通过基类指针进行。
解决办法之一是 用static_cast 执行基类指针向派生类指针的显式转换(不太安全)，只能在指针所指向对象的类型明确的情况下执行。
c++提供两种运行时类型识别的机制:
1. 用dynamic_cast 执行基类向派生类的转换
将基类的指针(或引用)显示转换为派生类的指针(或引用).
但与static_cast 不同的是，有条件的转换，转换前会检测指针(或引用)所指的对象的实际类型是否与转换的目的类型兼容，否则:
* 如果执行的是指针类型的转换，会得到空指针。
* 如果执行的是引用类型的转换，会抛出异常。
> 转换前类型必须是指向多态类型的指针(或引用)，因为c++只为多态类型在运行时保存用于运行时类型识别的信息。

