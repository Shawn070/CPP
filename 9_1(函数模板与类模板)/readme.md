>模板是C++支持参数化程序设计的工具，通过它可以实现参数化多态性。所谓参数化多态性概述就是将程序所处理的对象的类型参数化使得一段程序可以用于处理多种不同类型的对象。

# 1.函数模板
``` c++
template<模板参数表>
类型名 函数名(参数表)
{
	函数体的定义
}
```
模板参数表由用逗号分隔的模板参数构成，可以包括以下内容:
1. class(或yepename)标识符，指明可以接收一个类型参数。可以是类型，也可以是内部类型或自定义类型。
2. "类型说明符"标识符，指明可以接收一个由“类型说明符”所规定类型的常量作为参数。
3. template<参数表>class 标识符，指明可以接收一个类模板名作为参数。
例子:
``` c++
#include<iostream>
using namespace std;
template<typename T>
T abs(T x){
	return x<0?-x:x;
}
int main(){
	int n=-5;
	double d=-5.5;
	cout<<abs(n)<<endl;
	cout<<abs(d)<<endl;
	return 0;
}
```
>当类型参数的含义确定后，编译器将以函数模板为样板，生成一个函数，这一过程称为函数模板的实例化。例如:
``` c++
int abs(int x){
	return x<0?-x:x;
}
```

**注意**: 虽然函数模板的使用形式与函数类似，但二者有本质的区别:
1. 函数模板本身在编译时不会生成任何目标代码，只有由模板生成的实例会生成目标代码。
2. 被多个源文件引用的函数模板，应当连同函数体一同放到头文件中，而不能像普通函数那样只将声明放在头文件中。
3. 函数指针也只能指向模板的实例，而不能指向模板本身。

# 2.类模板
	使用类模板使用户可以为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数、返回值或局部变量能取任意类型(包括系统预定义的和用户自定义的)。
	类是对一组对象的公共性质的抽象，而类模板则是对不同类的公共性质的抽象，因此类模板是属于更高层次的抽象。
定义:
``` c++
template<模板参数表>
class 类名
{
	类成员声明
}
```

在类模板外定义其他函数成员:
``` c++
template<模板参数表>
类型名 类名<模板参数标识符列表>::函数名(参数表)
```
>一个类模板声明本身并不是一个类，它说明了类的一个家族。只有当被其他代码引用时，模板才根据引用的需要来生成具体的类。
使用一个模板类来建立对象:
``` c++
模板名<模板参数表>对象名1, ... , 对象名n; 
```


